for(i in c(1:3)){
net1 <- gen_sbm(N, node_membs, p_within, p_between)
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net1, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net1 %v% "x" = x[, 1]
net1 %v% "y" = x[, 2]
fig[[i]] <- ggnet2(net1, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
# Generate Latent Space Model (d = 2)
N <- 75
theta <- -2
pos <- t(sapply(1:N, function(x) { rnorm(2) }))
gen_lsm <- function(N, theta, pos) {
net <- matrix(0, nrow = N, ncol = N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
odds <- theta - norm(pos[i,] - pos[j, ], type = "2")
p <- exp(odds) / (1 + exp(odds))
net[i, j] <- rbinom(1, 1, p)
net[j, i] <- net[i, j]
}
}
net <- as.network(net, directed = FALSE)
return(net)
}
## Generate 3 layers of LSM
for(i in c(1:3)){
net2 <- gen_sbm(N, node_membs, p_within, p_between)
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net2, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net2 %v% "x" = x[, 1]
net2 %v% "y" = x[, 2]
fig[[i+3]] <- ggnet2(net2, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[4]],fig[[5]],fig[[6]],ncol = 3, nrow = 1)
# Generate Latent Space Model (d = 2)
N <- 75
theta <- -2
pos <- t(sapply(1:N, function(x) { rnorm(2) }))
gen_lsm <- function(N, theta, pos) {
net <- matrix(0, nrow = N, ncol = N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
odds <- theta - norm(pos[i,] - pos[j, ], type = "2")
p <- exp(odds) / (1 + exp(odds))
net[i, j] <- rbinom(1, 1, p)
net[j, i] <- net[i, j]
}
}
net <- as.network(net, directed = FALSE)
return(net)
}
## Generate 3 layers of LSM
for(i in c(1:3)){
net <- gen_lsm(N, theta, pos)
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net %v% "x" = x[, 1]
net %v% "y" = x[, 2]
fig[[i+3]] <- ggnet2(net, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[4]],fig[[5]],fig[[6]],ncol = 3, nrow = 1)
# Generate ERGM
N <- 75
theta <- c(-3.25, .5, .5)
## Generate 3 layers of ERGM
for(i in c(1:3)){
net <- simulate(network.initialize(N, directed = FALSE) ~ edges + gwesp,
coef = theta,
control = control.simulate(MCMC.burnin = 3e+6))
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net %v% "x" = x[, 1]
net %v% "y" = x[, 2]
fig[[i+6]] <- ggnet2(net, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[7]],fig[[8]],fig[[9]],ncol = 3, nrow = 1)
ggrange(fig[[1:9]],ncol = 3, nrow = 3)
ggarrange(fig[[1:9]],ncol = 3, nrow = 3)
fig[1]
fig[2]
fig[[2]]
fig[[1:2]]
fig[[1:3]]
a = c(1)
a.append(d)
a
append(a,3)
a
fig_list = list()
for(i in c(1:9)){
append(fig_list,fig[[i]])
}
ggarrange(plotlist = fig_list,ncol = 3, nrow = 3)
for(i in c(1:9)){
append(fig_list,fig[[i]])
}
fig_list
fig_list = list()
for(i in c(1:9)){
fig_list <- append(fig_list,fig[[i]])
}
View(fig_list)
ggarrange(plotlist = fig_list,ncol = 3, nrow = 3)
rm(list = ls())
library(ergm)
library(GGally)
library(latentnet)
library(ggplot2)
library(ggpubr)
require(grid)
library(reshape2)
library(sna)
## Create figure handles for each of the network
fig <- vector("list",length = 3*3)
node_colors <- c("orange","blue","purple")
# Generate SBM with K = 3 blocks
N <- 75
node_membs <- c(rep(1, 25), rep(2, 25), rep(3, 25))
p_within <- .25
p_between <- .01
gen_sbm <- function(N, node_membs, p_within, p_between) {
net <- matrix(0, nrow = N, ncol = N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
net[i, j] <- rbinom(1, 1, ifelse(node_membs[i] == node_membs[j], p_within, p_between))
net[j, i] <- net[i, j]
}
}
net <- as.network(net, directed = FALSE)
return(net)
}
## Generate 3 layers of SBM
for(i in c(1:3)){
net <- gen_sbm(N, node_membs, p_within, p_between)
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net %v% "x" = x[, 1]
net %v% "y" = x[, 2]
fig[[i]] <- ggnet2(net, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[1]],fig[[2]],fig[[3]],ncol = 3, nrow = 1)
# Generate Latent Space Model (d = 2)
N <- 75
theta <- -2
pos <- t(sapply(1:N, function(x) { rnorm(2) }))
gen_lsm <- function(N, theta, pos) {
net <- matrix(0, nrow = N, ncol = N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
odds <- theta - norm(pos[i,] - pos[j, ], type = "2")
p <- exp(odds) / (1 + exp(odds))
net[i, j] <- rbinom(1, 1, p)
net[j, i] <- net[i, j]
}
}
net <- as.network(net, directed = FALSE)
return(net)
}
## Generate 3 layers of LSM
for(i in c(1:3)){
net <- gen_lsm(N, theta, pos)
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net %v% "x" = x[, 1]
net %v% "y" = x[, 2]
fig[[i+3]] <- ggnet2(net, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[4]],fig[[5]],fig[[6]],ncol = 3, nrow = 1)
# Generate ERGM
N <- 75
theta <- c(-3.25, .5, .5)
## Generate 3 layers of ERGM
for(i in c(1:3)){
net <- simulate(network.initialize(N, directed = FALSE) ~ edges + gwesp,
coef = theta,
control = control.simulate(MCMC.burnin = 3e+6))
## x is the position of each node, use this for all networks
if(i == 1){
x = gplot.layout.fruchtermanreingold(net, NULL)
}
## Draw the SBM network, use "mode" argument to control the node position
net %v% "x" = x[, 1]
net %v% "y" = x[, 2]
fig[[i+6]] <- ggnet2(net, node.size = 6, node.color = node_colors[i], mode = c("x", "y") ) +
labs(title = paste0("Layer ", as.character(i))) +  ## Change the graph title here
theme(plot.title = element_text(hjust = 0.5,size = 30))   ## Change the font size here
}
## Arrange all 3 networks in one plot
ggarrange(fig[[7]],fig[[8]],fig[[9]],ncol = 3, nrow = 1)
rm(list = ls())
suppressMessages(library(latentnet))
suppressMessages(library(ergm))
library(GGally)
library(latentnet)
library(ggplot2)
library(ggpubr)
require(grid)
library(reshape2)
adv <- read.table("C:/Users/ljhhe/OneDrive - Florida State University/Research/Applications/Lazega/LazegaLawyers/ELadv.dat")
friend <- read.table("C:/Users/ljhhe/OneDrive - Florida State University/Research/Applications/Lazega/LazegaLawyers/ELfriend.dat")
work <- read.table("C:/Users/ljhhe/OneDrive - Florida State University/Research/Applications/Lazega/LazegaLawyers/ELwork.dat")
N <- length(adv[,1])
mlnetwork <- matrix(0,1,3)
worksym <- matrix(0,N,N)
advsym <- matrix(0,N,N)
friendsym <- matrix(0,N,N)
### Create symmetric adjacent matrix
## work = 1
## advice = 2
## friend = 3
for(i in c(1:(N-1))){
for(j in c((i + 1):N)){
if(work[i,j] == 1 && work[j,i] == 1){
mlnetwork <- rbind(mlnetwork,c(i,j,1))
worksym[i,j] = 1
worksym[j,i] = 1
}
if(adv[i,j] == 1 && adv[j,i] == 1){
mlnetwork <- rbind(mlnetwork,c(i,j,2))
advsym[i,j] = 1
advsym[j,i] = 1
}
if(friend[i,j] == 1 && friend[j,i] == 1){
mlnetwork <- rbind(mlnetwork,c(i,j,3))
friendsym[i,j] = 1
friendsym[j,i] = 1
}
}
}
mlnetwork <- mlnetwork[-1,]
samp_num <- 1
burnin <- 100
k <- 3  #number of layers
mdim <- 6
mterm <- rep("ml_order2",mdim)
intv <- 3
seed <- 123456
rNR_tol <- 1000
rNR_max <- 1000
rMCMLE_max <- 1000
g <- 0
for(i in c(1:(length(mlnetwork[,1])-1))){
if(mlnetwork[i,1] == mlnetwork[i+1,1] && mlnetwork[i,2] == mlnetwork[i+1,2]){
next
}
else g <- g + 1
}
gy <- g/choose(N,2)
## Goodness of Fit ##
s1 <- sum(as.integer(mlnetwork[,3] == 1))
s2 <- sum(as.integer(mlnetwork[,3] == 2))
s3 <- sum(as.integer(mlnetwork[,3] == 3))
suff_mat <- matrix(0,choose(N,2),7) ## matrix of sufficient statistics for each dyad: number of edges \times dimension
for(i in c(1:(N-1))){
for(j in c((i + 1):N)){
m <- ((N-1)+(N-i+1))*(i-1)/2 + j-i
if (worksym[i,j] == 1){
suff_mat[m, 1] <- 1
if(advsym[i,j] == 1){
suff_mat[m, 4] <- 1
if(friendsym[i,j] == 1){
suff_mat[m, 7] <- 1
}
}
}
if (advsym[i,j] == 1){
suff_mat[m, 2] <- 1
if (friendsym[i,j] == 1 ){
suff_mat[m, 6] <- 1
}
}
if (friendsym[i,j] == 1 ){
suff_mat[m, 3] <- 1
if (worksym[i,j] == 1){
suff_mat[m, 5] <- 1
}
}
}
}
suff_mat <- suff_mat[rowSums(suff_mat[])>0,]
s12 <- 0
s13 <- 0
s23 <- 0
s123 <- 0
for(i in c(1:(N-1))){
for(j in c((i + 1):N)){
m <- m + 1
if (worksym[i,j] == 1 && advsym[i,j] == 1){
s12 <- s12 + 1
}
if (worksym[i,j] == 1 && friendsym[i,j] == 1){
s13 <- s13 + 1
}
if (friendsym[i,j] == 1 && advsym[i,j] == 1){
s23 <- s23 + 1
}
if (friendsym[i,j] == 1 && advsym[i,j] == 1 && worksym[i,j] == 1 ){
s123 <- s123 + 1
}
}
}
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/private-cloud-codingspace/TEST-mlnet-separable-simulation")
library("devtools")
devtools::document()
### estimate and simulate many times
set.seed(202302)
nn <- 250
avg_simsuff <- rep(0,nn)
data_suff <- c(s1,s12,s13,s2,s23,s3,s123)
## Reproduce networks nn times
for(m in c(nn:nn)){
seeds <- sample(1:9999999,m,replace = FALSE)
sim_suff <- matrix(0,m, mdim + 1)
result <- rcpp_estimate_model_ml(mlnetwork, rNR_tol, rNR_max, rMCMLE_max, samp_num,  burnin, intv, mdim, mterm, N, k, TRUE, 202302,gy)
theta <- result$theta_est
adv_tri_sim <- rep(0,m)
friend_tri_sim <- rep(0,m)
work_tri_sim <- rep(0,m)
for(iter in c(1:m)){
seed <- seeds[iter]
simsample <- rcpp_simulate_ml_suffstats(samp_num, burnin, intv, mdim, mterm, N, k, theta,seed,gy) ## Need to find the correct gy first!!!
simnet <- rcpp_simulate_ml(samp_num, burnin, intv, mdim, mterm, N, k, theta,seed,gy)
simsamp <- do.call(rbind,simsample)
#simnetwork <- rcpp_simulate_ml(samp_num, burnin, intv, mdim, mterm, N, k, theta[iter,],seed,gy)
#NetMat <- do.call(rbind,simnetwork)
sim_suff[iter,] <- simsamp[,3]
work_sim <- matrix(0,N,N)
adv_sim <- matrix(0,N,N)
friend_sim <- matrix(0,N,N)
for(r in c(1:length(simnet$elist[,1]))){
row <- simnet$elist[r,1]
col <- simnet$elist[r,2]
layer <- simnet$elist[r,3]
if(layer == 1){
work_sim[row,col] <- 1
}
if(layer == 2){
adv_sim[row,col] <- 1
}
if(layer == 3){
friend_sim[row,col] <- 1
}
}
## Calculate the triangle statistic of simulated network
#
# for(i in c(1:(N-2))){
#   for (j in c((i+1):(N-1))){
#     for (h in c((j+1):N)){
#       adv_tri_sim[iter] <- adv_tri_sim[iter] + as.integer(adv_sim[i,j] == 1 && adv_sim[i,h] == 1 && adv_sim[j,h] == 1)
#       friend_tri_sim[iter] <- friend_tri_sim[iter] + as.integer(friend_sim[i,j] == 1 && friend_sim[i,h] == 1 && friend_sim[j,h] == 1)
#       work_tri_sim[iter] <- work_tri_sim[iter] + as.integer(work_sim[i,j] == 1 && work_sim[i,h] == 1 && work_sim[j,h] == 1)
#     }
#
#   }
# }
}
#avg_simsuff[m] <- norm(colMeans(sim_suff) - data_suff,"2")/norm(data_suff,"2")
}
avg_simsuff[m] <- norm(colMeans(sim_suff) - data_suff,"2")/norm(data_suff,"2")
avg_simsuff
work_tri_sim
sim_suff
work_sim
avg_simsuff
suff_y <- c(sim_suff[,1],sim_suff[,4],sim_suff[,6],sim_suff[,2],sim_suff[,3],sim_suff[,5],sim_suff[,7])
df <- data.frame(suff_y,name = as.factor(rep(c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF"),each = 10)))
dim_x <- c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF")
df$name <- factor(df$name,levels = c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF"))
suff_mean <- colMeans(sim_suff)[c(1,4,6,2,3,5,7)]
#df <- data.frame(dim_x , suff_mean)
upper <- suff_mean + 1.96*apply(sim_suff,2,sd)
lower <- suff_mean - 1.96*apply(sim_suff,2,sd)
fig1 <- ggplot(df,aes(x = name, y = suff_y)) +
geom_boxplot(fill = "grey") +
geom_point( size = 3,aes(x = name,y=rep(suff_mean,each = 10)),color="red") +
theme_classic() +
labs(title = expression(paste("Box-plot of the reproduced sufficient statistic")) , x = "Layer interaction", y ="Sufficient statistic") +
theme(plot.title = element_text(hjust = 0.5,size = 20),
axis.text = element_text(size=15),
axis.title=element_text(size=20),
panel.border = element_rect(colour = "black", fill=NA,linewidth = 1),
#legend.title = element_text( size = 30),
#legend.text = element_text( size = 30),
#legend.position = "right",
#legend.key.width = unit(5, 'cm'),
#legend.background = element_blank(),
legend.box.background = element_rect(colour = "black",linewidth = 1)) +
scale_color_manual(values = c("red"))
fig1
fig1 <- ggplot(df,aes(x = name, y = suff_y)) +
geom_boxplot(fill = "grey") +
geom_point( size = 3,aes(x = name,y=rep(suff_mean,each = nn)),color="red") +
theme_classic() +
labs(title = expression(paste("Box-plot of the reproduced sufficient statistic")) , x = "Layer interaction", y ="Sufficient statistic") +
theme(plot.title = element_text(hjust = 0.5,size = 20),
axis.text = element_text(size=15),
axis.title=element_text(size=20),
panel.border = element_rect(colour = "black", fill=NA,linewidth = 1),
#legend.title = element_text( size = 30),
#legend.text = element_text( size = 30),
#legend.position = "right",
#legend.key.width = unit(5, 'cm'),
#legend.background = element_blank(),
legend.box.background = element_rect(colour = "black",linewidth = 1)) +
scale_color_manual(values = c("red"))
fig1
suff_mean
fig1 <- ggplot(df,aes(x = name, y = suff_y)) +
geom_boxplot(fill = "grey") +
geom_point( size = 3,aes(x = name,y=rep(suff_mean,each = 10)),color="red") +
theme_classic() +
labs(title = expression(paste("Box-plot of the reproduced sufficient statistic")) , x = "Layer interaction", y ="Sufficient statistic") +
theme(plot.title = element_text(hjust = 0.5,size = 20),
axis.text = element_text(size=15),
axis.title=element_text(size=20),
panel.border = element_rect(colour = "black", fill=NA,linewidth = 1),
#legend.title = element_text( size = 30),
#legend.text = element_text( size = 30),
#legend.position = "right",
#legend.key.width = unit(5, 'cm'),
#legend.background = element_blank(),
legend.box.background = element_rect(colour = "black",linewidth = 1)) +
scale_color_manual(values = c("red"))
fig1
suff_mean
rep(suff_mean,each = nn)
suff_mean
name
suff_y
df$name
suff_y <- c(sim_suff[,1],sim_suff[,4],sim_suff[,6],sim_suff[,2],sim_suff[,3],sim_suff[,5],sim_suff[,7])
df <- data.frame(suff_y,name = as.factor(rep(c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF"),each = nn)))
dim_x <- c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF")
df$name <- factor(df$name,levels = c("Coworker", "Advice", "Friendship", "CxA","CxF","AxF","CxAxF"))
suff_mean <- colMeans(sim_suff)[c(1,4,6,2,3,5,7)]
#df <- data.frame(dim_x , suff_mean)
upper <- suff_mean + 1.96*apply(sim_suff,2,sd)
lower <- suff_mean - 1.96*apply(sim_suff,2,sd)
fig1 <- ggplot(df,aes(x = name, y = suff_y)) +
geom_boxplot(fill = "grey") +
geom_point( size = 3,aes(x = name,y=rep(suff_mean,each = nn)),color="red") +
theme_classic() +
labs(title = expression(paste("Box-plot of the reproduced sufficient statistic")) , x = "Layer interaction", y ="Sufficient statistic") +
theme(plot.title = element_text(hjust = 0.5,size = 20),
axis.text = element_text(size=15),
axis.title=element_text(size=20),
panel.border = element_rect(colour = "black", fill=NA,linewidth = 1),
#legend.title = element_text( size = 30),
#legend.text = element_text( size = 30),
#legend.position = "right",
#legend.key.width = unit(5, 'cm'),
#legend.background = element_blank(),
legend.box.background = element_rect(colour = "black",linewidth = 1)) +
scale_color_manual(values = c("red"))
fig1
fig1 <- ggplot(df,aes(x = name, y = suff_y)) +
geom_boxplot(fill = "grey") +
geom_point( size = 3,aes(x = name,y=rep(suff_mean,each = nn)),color="red") +
theme_classic() +
labs(title = expression(paste("Box-plot of the reproduced sufficient statistic")) , x = "Layer interaction", y ="Sufficient statistic") +
theme(plot.title = element_text(hjust = 0.5,size = 15),
axis.text = element_text(size=10),
axis.title=element_text(size=15),
panel.border = element_rect(colour = "black", fill=NA,linewidth = 1),
#legend.title = element_text( size = 30),
#legend.text = element_text( size = 30),
#legend.position = "right",
#legend.key.width = unit(5, 'cm'),
#legend.background = element_blank(),
legend.box.background = element_rect(colour = "black",linewidth = 1)) +
scale_color_manual(values = c("red"))
fig1
avg_simsuff[m]
norm(colMeans(sim_suff) - data_suff,"2")/norm(data_suff,"2")
colMeans(sim_suff)
data_suff
